## HTML

#### 语义化
****
1. 语义化，对文本内容结构化（内容语义化），选择合乎语义的标签（代码语义化）。

2. 例子：header、nav、main、article、section、aside、footer等。
3. 优点：

- 代码结构清晰，易于阅读，有利于维护
- 方便其他设备解析（如：屏幕阅读器）
- 有利于搜索引擎优化（SEO），搜索引擎爬虫会根据不同的标签来赋予不同的权重
详细文章：[百度ife的h5语义化文章](https://link.juejin.cn/?target=https%3A%2F%2Frainylog.com%2Fpost%2Fife-note-1%2F)



#### 行内元素，块级元素有哪些

----

- 行内元素：a、b、span、img、input、select、strong
- 块级元素：div、ul、ol、dl、dd、h1、p
- 空元素：br、hr、img、link、meta



#### html5为什么只要写<!DOUCTYPE>

----

**SGML：**标准通用标记语言（以下简称“通用标言”），是一种定义[电子文档](https://baike.baidu.com/item/电子文档)结构和描述其内容的[国际标准](https://baike.baidu.com/item/国际标准)语言；[1] 通用标言为语法置标提供了异常强大的工具，同时具有极好的扩展性，因此在[数据分类](https://baike.baidu.com/item/数据分类)和索引中非常有用；[2] 是所有电子文档标记语言的起源，早在[万维网](https://baike.baidu.com/item/万维网)发明之前“通用标言”就已存在。[1] 

 **DTD：**文档类型定义(Document Type Definition)是一套为了进行程序间的数据交换而建立的关于标记符的语法规则。它是[标准通用标记语言](https://baike.baidu.com/item/标准通用标记语言)和[可扩展标记语言](https://baike.baidu.com/item/可扩展标记语言)1.0版规格的一部分，文档可根据某种DTD语法规则验证格式是否符合此规则。文档类型定义也可用做保证标准通用标记语言、可扩展标记语言文档格式的合法性，可通过比较文档和文档类型定义文件来检查文档是否符合规范，元素和标签使用是否正确。文件实例提供应用程序一个数据交换的格式。使用各类文档类型定义是为了让标准通用标记语言、可扩展标记语言文件能符合规定的数据交换标准，因为这样，不同的公司只需定义好标准文档类型定义，就都能依文档类型定义建立文档实例，并且进行验证，如此就可以轻易交换数据，防止了实例数据定义不同等原因造成的数据交换障碍，满足了网络共享和数据交互。文档类型定义文件是一个[美国信息交换标准代码](https://baike.baidu.com/item/美国信息交换标准代码)文本文件。

- DOCTYPE声明不是一个 HTML 标签；它是用来告知 Web 浏览器页面使用了哪种 HTML 版本。[HTML5](https://so.csdn.net/so/search?q=HTML5&spm=1001.2101.3001.7020) 不是基于 SGML的，因此不需要对DTD进行引用，但是仍然需要doctype来规范浏览器的行为，至于不声明DOCTYPE的后果，就是某些css的处理方式是根据浏览器喜好定的，不是根据标准走的，这样同一份代码在不同浏览器可能产生不同效果，所以写之前必须声明！而HTML4.01基于SGML,所以需要对DTD进行引用，才能告知浏览器文档所使用的文档类型



#### script标签属性中async和defer的区别
****
- script会阻碍HTML解析，只有下载好并执行完脚本了才会继续解析HTML
- async：解析HTML的时候，会进行脚本异步下载，下载成功后立马执行。所以也可能阻断HTML的解析。多个脚本的执行顺序无法保证。
- defer：也是异步下载，下载完后，如果HTML还没有解析完，游览器不会暂停解析，会等待HTML解析完毕后执行JS代码。如果存在多个这个标签，游览器（IE9及以下除外）会保证它们按照在HTML中出现的顺序执行，不会破坏JS脚本之间的依赖关系

详细文章：[图解 script 标签中的 async 和 defer 属性](https://juejin.cn/post/6894629999215640583)

#### SGML、HTML、XML、XHTML的区别
****
- SGML是标准通用标记语言，是一种定义电子文档结构和描述其内容的国际标准语言，是所有电子文档标记语言的起源。
- HTML是超文本标记语言，主要是用于规定怎样显示网页。
- XML是可扩展标记语言，是未来网页语言的发展方向，XML和HTML的最大区别在于XML的标签是可以自己创建的，数量无限多，而HTML的标签都是固定的而且数量有限。
- XHTML和HTML没有什么本质的区别，标签用法都一样，就是比HTML更严格，标签必须都用小写，标签都必须闭合等。
#### HTML5有哪些新特性、移除了哪些元素？
****
HTML5已经不是SGML的子集，增加一些关于图像、位置、存储、多任务等功能的增加。

新增：
- 绘图canvas

- 用于媒介播放的video和audio元素

- 本地化离线存储localStorage、sessionStorage

- 语义化更好的内容元素，标签。header，main，nav，footer等

- 表单控件，input标签的属性，calender、date、time、email、url、search等

- 新技术webworker、websocket

- 新的文档属性document.visibilityState

移除：

- 纯表现的元素：basefont、big、center、s、tt、u

- 对可用性产生负面影响的元素：frame、frameset、noframes
#### 对游览器内核的理解
****
主要分为两部分：渲染引擎和JS引擎。
- 渲染引擎：在游览器窗口中显示所请求的内容。默认情况下，渲染引擎可以显示HTML、XML文档及图片，它也可以借助一些游览器扩展插件显示其他类型数据，如：使用PDF阅读器插件可以显示PDF格式。
- JS引擎：解析和执行JavaScript来实现网页的动态效果。
最开始渲染和js引擎并没有区分的很明显，后来JS引擎越来越独立，内核就倾向于只指渲染引擎了
#### 什么是文档的预解析？
****
当执行js脚本时，另一个线程解析剩下的文档，并加载后面需要通过网络加载的资源。这种方式可以使资源并行加载，从而使整体速度更快。
		注意：预解析并不改变DOM树，它将这个工作交给主解析过程，自己只解析外部资源的引用，比如：外部脚本、样式及图片。

#### 游览器的渲染原理（游览器.md中详细说明，这里简要概括）
****
简单记忆：生成DOM树-->生成CSS规则树-->构建渲染树-->布局-->绘制
		

1.首先解析收到的文档，根据文档定义构建一颗DOM树，DOM树是由DOM元素及属性节点组成的。
		

2.然后对CSS进行解析，生成CSS规则树。
		

3.根据DOM和 CSS树构建渲染树。渲染树的节点被称为渲染对象，它是一个包含有颜色等属性的矩形。渲染对象和DOM元素相对应，但这种关系不是一对一的，不可见的DOM元素不会插入渲染树。还有一些DOM元素对应几个可见对象，它们一般是一些具有复杂结构的元素，无法用一个矩形来描述。
		

4.当渲染对象被创建并添加到树中，它们没有位置和大小，所以当游览器生成渲染树以后，就会根据渲染树来进行布局（也可以叫做回流）。这一阶段游览器要做的是计算出各个节点在页面中确切位置和大小。通常这一行为也被称为自动重排。
		

5.布局阶段结束后是绘制阶段，遍历渲染树并调用渲染对象的paint方法将它们的内容显示到屏幕上。值得注意的是，这个过程是逐步完成的，为了更好的用户体验，渲染引擎会尽早的将内容呈现到屏幕上，并不会等到所有的HTML内容都解析完之后再去构建和布局渲染树，它是解析完一部分内容就显示一部分内容，同时，可能还通过网络下载其余内容。

#### 什么是回流和重绘
****
1.概念：

- 回流：当DOM的变化影响了元素的几何信息，游览器需要重新计算元素的几何属性，将其安放在界面中的正确位置，这个过程叫做重排，表现为重新生成布局，重新排列元素。
- 重绘：当一个元素的外观发生改变，重新把元素外观绘制出来的过程，叫做重绘。表现为某些元素的外观被改变。

2.常见引起回流和重绘的属性和方法：

任何会改变元素几何信息（元素的位置和尺寸大小）的操作都会触发回流。

- 添加或删除可见的DOM元素。
- 元素尺寸改变：边距、填充、宽度、高度等
- 游览器尺寸改变：resize事件发生时
- 计算offsetWidth和offsetHeight属性
- 设置style属性的值
- 修改网页默认字体。
- 页面一开始渲染的时候

**回流必定会发生重绘，重绘不一定会引发回流。**

**回流所需的成本比重绘高得多**

详细文章：[你真的了解回流和重绘吗](https://juejin.cn/post/6844903779700047885)

#### 如何减少回流
****
- 使用transform代替top；使用css3硬件加速，可以让 transform、opacity、filters、will-change 这些动画不会引起回流重绘 （会提高内存占用）。
- 使用绝对定位让复杂动画脱离文档流减少父元素以及后续元素频繁的回流。
- 不要把节点的属性放值放在一个循环里，当成循环里的变量。
- 不要使用table布局，可能很小的一个改动会造成整个table的重新布局。
- 把DOM离线后修改。如：使用documentFragment对象在内存里操作DOM
- 不要一条一条的修改样式，可以预先定义好class，然后修改DOM的calssName
- 使用absolute或fixed使元素脱离文档流，例如上述的动画。
#### sessionStorage，localStorage和cookie的区别。
****
1.共同点：都是保存在游览器端，且同源的。

2.区别：

- cookie始终在同源的http请求中携带（即使不需要），即cookie在游览器和服务器之间来回传递；而sessionStorage和localStorage不会自动把数据发送到服务器，仅在本地保存。cookie还有路径（path）的概念，可以限制cookie只属于某个路径下。
- 存储大小限制不同。cookie不能超过4K，因为每次http请求都会携带cookie，所以cookie只适合保存很小的数据，如：会话标识。sessionStorage和localStorage虽然也有存储大小限制，但比cookie大得多，可以达到5M或更大。
- 数据有效期不同。sessionStorage仅在当前游览器窗口关闭之前有效；localStorage始终有效，窗口或游览器关闭也一直保存，因此用作持久数据；cookie只在设置的cookie过期时间之前有效。
- 作用域不同。sessionStorage不在不同的游览器窗口中共享，即使是同一个页面；localStorage和cookie在所有同源窗口中都是共享的。
#### iframe有哪些优缺点？
****
优点：

1.iframe能原封不动的把嵌入的网页展现出来。

2.如果有多个网页引入iframe，只需修改iframe的内容，就可以实现调用每一个页面的更改，方便快捷。

缺点：

1.iframe会阻塞主页面的onload事件。

2.iframe和主页面共享链接池，而游览器对相同域的链接有限制，所以会影响页面的并行加载。

3.不利于SEO，代码复杂，无法一下被搜索引擎引到。

4.iframe框架页面会增加服务器的http请求，对于大型网站不可取。

5.很多移动设备无法完全显示框架，设备兼容性差。

注意：通过动态给iframe添加src属性值，可以解决前两个问题。
#### 什么是canvas，基本用法？
****
是HTML5的一部分，允许脚本语言动态渲染位图像。canvas由一个可控制区域HTML代码中的属性定义决定高度和宽度。JS代码可以访问该区域，通过一套完整的绘图功能（类似于其他的通用二位的API）从而生成动态的图形。

可用于游戏和图标(echarts.js、heightChart.js都是基于canvas来绘图)制作的

1.创建canvas标签

```javascript
<canvas id="myCanvas" width="150" height="150">该浏览器不支持canvas</canvas>
```

2.渲染上下文

```javascript
var canvas = document.getElementById('myCanvas');
var ctx = canvas.getContext('2d');
```

通过获取<canvas>元素对应的DOM对象（document.getElementById()）方法获取。然后通过使用它的getContext()方法来绘制上下文。创建canvas标签时可以在标签内写上不支持的提示信息；也可以通过getContext()方法判断是否支持编程

```javascript
var canvas = document.getElementById('myCanvas');
if (canvas.getContext) {
  var ctx = canvas.getContext('2d');
  // other code
} else {
  // 不支持 canvas 的其他代码
}
```

#### WebSocket

----

http是单向的。如果只能客服端向服务端发请求获取东西，如果想要每时每刻获取信息。只能轮询请求才行；

所以要用websocket；